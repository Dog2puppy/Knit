{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knit \u00b6 A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. Getting Started","title":"Home"},{"location":"#knit","text":"A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. Getting Started","title":"Knit"},{"location":"controllers/","text":"TODO","title":"Controllers"},{"location":"executionmodel/","text":"TODO","title":"Execution Model"},{"location":"gettingstarted/","text":"Install \u00b6 Installing Knit is very simple. Just drop in the module into ReplicatedStorage. Knit can also be used within a Rojo project. Standard workflow: Get Knit from the Roblox library. Place Knit directly within the ReplicatedStorage service. Rojo workflow: Get Knit [TODO] from the latest release on GitHub. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage. Basic Usage \u00b6 The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. A Simple Service \u00b6 A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money = money + amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): await () Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): andThen ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"Getting Started"},{"location":"gettingstarted/#install","text":"Installing Knit is very simple. Just drop in the module into ReplicatedStorage. Knit can also be used within a Rojo project. Standard workflow: Get Knit from the Roblox library. Place Knit directly within the ReplicatedStorage service. Rojo workflow: Get Knit [TODO] from the latest release on GitHub. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage.","title":"Install"},{"location":"gettingstarted/#basic-usage","text":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples.","title":"Basic Usage"},{"location":"gettingstarted/#a-simple-service","text":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money = money + amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): await () Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): andThen ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"A Simple Service"},{"location":"knitapi/","text":"Knit \u00b6 Knit.Services: [Service] \u00b6 [Server-side only] A table that contains all created services. 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Controllers: [Controller] \u00b6 [Client-side only] A table that contains all created controllers. 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Start() -> Promise \u00b6 Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): andThen ( function () print ( \"Knit is running\" ) end ) Knit.CreateService(service: Table) -> Service \u00b6 [Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} } Knit.CreateController(controller: Table) -> Controller \u00b6 [Client-side only] Creates a new controller. Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" } Knit.GetService(serviceName: String) -> ServiceMirror \u00b6 [Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): andThen ( function () ... end ) Service \u00b6 A service is a singleton object that serves a specific purpose on the server. Service.Name: String \u00b6 The name of the service. Service.Client: ServiceClient \u00b6 A ServiceClient table that contains client-exposed methods and events. Service:KnitInit() -> Void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Service:KnitStart() -> Void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Service.CUSTOM_FIELD: Any \u00b6 Service:CUSTOM_METHOD(...) -> Any \u00b6 Service.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceClient \u00b6 Refers to the the Client table within a service . ServiceClient.Server: Service \u00b6 A reference back to the top-level service . ServiceClient:CUSTOM_METHOD(player, ...) -> Any \u00b6 ServiceClient.CUSTOM_EVENT:Fire(player, ...) -> Void \u00b6 ServiceClient.CUSTOM_EVENT:FireAll(...) -> Void \u00b6 ServiceClient.CUSTOM_EVENT:FireExcept(player, ...) -> Void \u00b6 Controller \u00b6 A controller is a singleton object that serves a specific purpose on the client. Controller.Name: String \u00b6 The name of the controller. Controller:KnitInit() -> Void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Controller:KnitStart() -> Void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Controller.CUSTOM_FIELD: Any \u00b6 Controller:CUSTOM_METHOD(...) -> Any \u00b6 Controller.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceMirror \u00b6 A table that mirrors the methods and events that were exposed on the server via the Client table. ServiceMirror:CUSTOM_METHOD(...) -> Any \u00b6 ServiceMirror:CUSTOM_METHODPromise(...) -> Promise \u00b6 ServiceMirror.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -> Void \u00b6","title":"Knit API"},{"location":"knitapi/#knit","text":"","title":"Knit"},{"location":"knitapi/#knitservices-service","text":"[Server-side only] A table that contains all created services. 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Services: [Service]"},{"location":"knitapi/#knitcontrollers-controller","text":"[Client-side only] A table that contains all created controllers. 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Controllers: [Controller]"},{"location":"knitapi/#knitstart-promise","text":"Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): andThen ( function () print ( \"Knit is running\" ) end )","title":"Knit.Start() -&gt; Promise"},{"location":"knitapi/#knitcreateserviceservice-table-service","text":"[Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} }","title":"Knit.CreateService(service: Table) -&gt; Service"},{"location":"knitapi/#knitcreatecontrollercontroller-table-controller","text":"[Client-side only] Creates a new controller. Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" }","title":"Knit.CreateController(controller: Table) -&gt; Controller"},{"location":"knitapi/#knitgetserviceservicename-string-servicemirror","text":"[Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): andThen ( function () ... end )","title":"Knit.GetService(serviceName: String) -&gt; ServiceMirror"},{"location":"knitapi/#service","text":"A service is a singleton object that serves a specific purpose on the server.","title":"Service"},{"location":"knitapi/#servicename-string","text":"The name of the service.","title":"Service.Name: String"},{"location":"knitapi/#serviceclient-serviceclient","text":"A ServiceClient table that contains client-exposed methods and events.","title":"Service.Client: ServiceClient"},{"location":"knitapi/#serviceknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Service:KnitInit() -&gt; Void"},{"location":"knitapi/#serviceknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Service:KnitStart() -&gt; Void"},{"location":"knitapi/#servicecustom_field-any","text":"","title":"Service.CUSTOM_FIELD: Any"},{"location":"knitapi/#servicecustom_method-any","text":"","title":"Service:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#servicecustom_eventfire-void","text":"","title":"Service.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#serviceclient","text":"Refers to the the Client table within a service .","title":"ServiceClient"},{"location":"knitapi/#serviceclientserver-service","text":"A reference back to the top-level service .","title":"ServiceClient.Server: Service"},{"location":"knitapi/#serviceclientcustom_methodplayer-any","text":"","title":"ServiceClient:CUSTOM_METHOD(player, ...) -&gt; Any"},{"location":"knitapi/#serviceclientcustom_eventfireplayer-void","text":"","title":"ServiceClient.CUSTOM_EVENT:Fire(player, ...) -&gt; Void"},{"location":"knitapi/#serviceclientcustom_eventfireall-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireAll(...) -&gt; Void"},{"location":"knitapi/#serviceclientcustom_eventfireexceptplayer-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireExcept(player, ...) -&gt; Void"},{"location":"knitapi/#controller","text":"A controller is a singleton object that serves a specific purpose on the client.","title":"Controller"},{"location":"knitapi/#controllername-string","text":"The name of the controller.","title":"Controller.Name: String"},{"location":"knitapi/#controllerknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Controller:KnitInit() -&gt; Void"},{"location":"knitapi/#controllerknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Controller:KnitStart() -&gt; Void"},{"location":"knitapi/#controllercustom_field-any","text":"","title":"Controller.CUSTOM_FIELD: Any"},{"location":"knitapi/#controllercustom_method-any","text":"","title":"Controller:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#controllercustom_eventfire-void","text":"","title":"Controller.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#servicemirror","text":"A table that mirrors the methods and events that were exposed on the server via the Client table.","title":"ServiceMirror"},{"location":"knitapi/#servicemirrorcustom_method-any","text":"","title":"ServiceMirror:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#servicemirrorcustom_methodpromise-promise","text":"","title":"ServiceMirror:CUSTOM_METHODPromise(...) -&gt; Promise"},{"location":"knitapi/#servicemirrorcustom_eventfire-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#servicemirrorcustom_eventconnectfunction-end-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -&gt; Void"},{"location":"services/","text":"TODO","title":"Services"}]}