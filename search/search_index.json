{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knit \u00b6 A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. Getting Started","title":"Home"},{"location":"#knit","text":"A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. Getting Started","title":"Knit"},{"location":"controllers/","text":"TODO","title":"Controllers"},{"location":"executionmodel/","text":"Order of Operations \u00b6 The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time The promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): await () Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called. Best Practices \u00b6 Only one Script on the server should manage loading services and starting the Knit Only one LoalScript on the client shoudl manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client","title":"Execution Model"},{"location":"executionmodel/#order-of-operations","text":"The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time The promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): await () Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called.","title":"Order of Operations"},{"location":"executionmodel/#best-practices","text":"Only one Script on the server should manage loading services and starting the Knit Only one LoalScript on the client shoudl manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client","title":"Best Practices"},{"location":"gettingstarted/","text":"Install \u00b6 Installing Knit is very simple. Just drop in the module into ReplicatedStorage. Knit can also be used within a Rojo project. Standard workflow: Get Knit from the Roblox library. Place Knit directly within the ReplicatedStorage service. Rojo workflow: Get Knit [TODO] from the latest release on GitHub. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage. Basic Usage \u00b6 The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. A Simple Service \u00b6 A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money = money + amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): await () Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): andThen ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"Getting Started"},{"location":"gettingstarted/#install","text":"Installing Knit is very simple. Just drop in the module into ReplicatedStorage. Knit can also be used within a Rojo project. Standard workflow: Get Knit from the Roblox library. Place Knit directly within the ReplicatedStorage service. Rojo workflow: Get Knit [TODO] from the latest release on GitHub. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage.","title":"Install"},{"location":"gettingstarted/#basic-usage","text":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples.","title":"Basic Usage"},{"location":"gettingstarted/#a-simple-service","text":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money = money + amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): await () Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): andThen ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"A Simple Service"},{"location":"knitapi/","text":"Knit \u00b6 Knit.Services: [Service] \u00b6 [Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Controllers: [Controller] \u00b6 [Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Util: Folder \u00b6 A folder containing utility modules used by Knit, but also accessible for developers to use. This folder contains the following modules: Maid Event Promise Thread They can be required like any other module: 1 local Event = require ( Knit . Util . Event ) Knit.Start() -> Promise \u00b6 Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): andThen ( function () print ( \"Knit is running\" ) end ) Knit.CreateService(service: Table) -> Service \u00b6 [Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} } Knit.CreateController(controller: Table) -> Controller \u00b6 [Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" } Knit.GetService(serviceName: String) -> ServiceMirror \u00b6 [Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): andThen ( function () ... end ) Service \u00b6 A service is a singleton object that serves a specific purpose on the server. Service.Name: String \u00b6 The name of the service. Service.Client: ServiceClient \u00b6 A ServiceClient table that contains client-exposed methods and events. Service:KnitInit() -> Void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Service:KnitStart() -> Void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Service.CUSTOM_FIELD: Any \u00b6 Service:CUSTOM_METHOD(...) -> Any \u00b6 Service.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceClient \u00b6 Refers to the the Client table within a service . ServiceClient.Server: Service \u00b6 A reference back to the top-level service . ServiceClient:CUSTOM_METHOD(player, ...) -> Any \u00b6 ServiceClient.CUSTOM_EVENT:Fire(player, ...) -> Void \u00b6 ServiceClient.CUSTOM_EVENT:FireAll(...) -> Void \u00b6 ServiceClient.CUSTOM_EVENT:FireExcept(player, ...) -> Void \u00b6 Controller \u00b6 A controller is a singleton object that serves a specific purpose on the client. Controller.Name: String \u00b6 The name of the controller. Controller:KnitInit() -> Void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Controller:KnitStart() -> Void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Controller.CUSTOM_FIELD: Any \u00b6 Controller:CUSTOM_METHOD(...) -> Any \u00b6 Controller.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceMirror \u00b6 A table that mirrors the methods and events that were exposed on the server via the Client table. ServiceMirror:CUSTOM_METHOD(...) -> Any \u00b6 ServiceMirror:CUSTOM_METHODPromise(...) -> Promise \u00b6 ServiceMirror.CUSTOM_EVENT:Fire(...) -> Void \u00b6 ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -> Void \u00b6","title":"Knit API"},{"location":"knitapi/#knit","text":"","title":"Knit"},{"location":"knitapi/#knitservices-service","text":"[Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Services: [Service]"},{"location":"knitapi/#knitcontrollers-controller","text":"[Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Controllers: [Controller]"},{"location":"knitapi/#knitutil-folder","text":"A folder containing utility modules used by Knit, but also accessible for developers to use. This folder contains the following modules: Maid Event Promise Thread They can be required like any other module: 1 local Event = require ( Knit . Util . Event )","title":"Knit.Util: Folder"},{"location":"knitapi/#knitstart-promise","text":"Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): andThen ( function () print ( \"Knit is running\" ) end )","title":"Knit.Start() -&gt; Promise"},{"location":"knitapi/#knitcreateserviceservice-table-service","text":"[Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} }","title":"Knit.CreateService(service: Table) -&gt; Service"},{"location":"knitapi/#knitcreatecontrollercontroller-table-controller","text":"[Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" }","title":"Knit.CreateController(controller: Table) -&gt; Controller"},{"location":"knitapi/#knitgetserviceservicename-string-servicemirror","text":"[Client-side only] Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): andThen ( function () ... end )","title":"Knit.GetService(serviceName: String) -&gt; ServiceMirror"},{"location":"knitapi/#service","text":"A service is a singleton object that serves a specific purpose on the server.","title":"Service"},{"location":"knitapi/#servicename-string","text":"The name of the service.","title":"Service.Name: String"},{"location":"knitapi/#serviceclient-serviceclient","text":"A ServiceClient table that contains client-exposed methods and events.","title":"Service.Client: ServiceClient"},{"location":"knitapi/#serviceknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Service:KnitInit() -&gt; Void"},{"location":"knitapi/#serviceknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Service:KnitStart() -&gt; Void"},{"location":"knitapi/#servicecustom_field-any","text":"","title":"Service.CUSTOM_FIELD: Any"},{"location":"knitapi/#servicecustom_method-any","text":"","title":"Service:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#servicecustom_eventfire-void","text":"","title":"Service.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#serviceclient","text":"Refers to the the Client table within a service .","title":"ServiceClient"},{"location":"knitapi/#serviceclientserver-service","text":"A reference back to the top-level service .","title":"ServiceClient.Server: Service"},{"location":"knitapi/#serviceclientcustom_methodplayer-any","text":"","title":"ServiceClient:CUSTOM_METHOD(player, ...) -&gt; Any"},{"location":"knitapi/#serviceclientcustom_eventfireplayer-void","text":"","title":"ServiceClient.CUSTOM_EVENT:Fire(player, ...) -&gt; Void"},{"location":"knitapi/#serviceclientcustom_eventfireall-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireAll(...) -&gt; Void"},{"location":"knitapi/#serviceclientcustom_eventfireexceptplayer-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireExcept(player, ...) -&gt; Void"},{"location":"knitapi/#controller","text":"A controller is a singleton object that serves a specific purpose on the client.","title":"Controller"},{"location":"knitapi/#controllername-string","text":"The name of the controller.","title":"Controller.Name: String"},{"location":"knitapi/#controllerknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Controller:KnitInit() -&gt; Void"},{"location":"knitapi/#controllerknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Controller:KnitStart() -&gt; Void"},{"location":"knitapi/#controllercustom_field-any","text":"","title":"Controller.CUSTOM_FIELD: Any"},{"location":"knitapi/#controllercustom_method-any","text":"","title":"Controller:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#controllercustom_eventfire-void","text":"","title":"Controller.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#servicemirror","text":"A table that mirrors the methods and events that were exposed on the server via the Client table.","title":"ServiceMirror"},{"location":"knitapi/#servicemirrorcustom_method-any","text":"","title":"ServiceMirror:CUSTOM_METHOD(...) -&gt; Any"},{"location":"knitapi/#servicemirrorcustom_methodpromise-promise","text":"","title":"ServiceMirror:CUSTOM_METHODPromise(...) -&gt; Promise"},{"location":"knitapi/#servicemirrorcustom_eventfire-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Fire(...) -&gt; Void"},{"location":"knitapi/#servicemirrorcustom_eventconnectfunction-end-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -&gt; Void"},{"location":"services/","text":"Services Defined \u00b6 Services are singleton objects that serve a specific purpose. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page. Creating Services \u00b6 In it's simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table otional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services and controllers. Adding methods \u00b6 Services are just simple tables at the end of the day. As such, it is very easy to add methods to the service. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end Adding properties \u00b6 Again, services are just tables. So we can simply add in fields as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retreive points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {} Using methods and properties \u00b6 Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points = points + amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end Using events \u00b6 What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Event module and create PointsChanged event: local Event = require ( Knit . Util . Event ) PointsService . PointsChanged = Event . new () -- Modify AddPoints event: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points -- Fire event, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end KnitInit and KnitStart \u00b6 In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under Execution Model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up you service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. Cleaning Up Unused Memory \u00b6 Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. Client Communication \u00b6 Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. Methods \u00b6 Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points ) Events (Server-to-Client) \u00b6 We should also create an event that we can fire for the clients when their points change. We can use the Event module again, and just put one within the Client table: 1 PointsService . Client . PointsChanged = Event . new () Under the hood, Knit is creating a RemoteEvent linked to this event. This is a two-way event (like a tranceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this event too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client event: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for the event: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end ) Events (Client-to-Server) \u00b6 Events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just role with it. We will create another client-exposed event called GiveMePoints which will randomly give the player points. Again, this is nonesense in the context of an actual game, but useful for example. Let's create the event on the PointsService: 1 PointsService . Client . GiveMePoints = Event . new () Now, let's listen for the client to call this event. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this event, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the event like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the event: PointsService . GiveMePoints : Fire () Full Example \u00b6 PointsService \u00b6 At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Event = require ( Knit . Util . Event ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed events/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Event . new () -- Client exposed events: PointsService . Client . PointsChanged = Event . new () PointsService . Client . GiveMePoints = Event . new () -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Event . new (); Client = { PointsChanged = Event . new (); GiveMePoints = Event . new (); }; } -- The rest of code here Client Consumer LocalScript \u00b6 Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): andThen ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Services"},{"location":"services/#services-defined","text":"Services are singleton objects that serve a specific purpose. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page.","title":"Services Defined"},{"location":"services/#creating-services","text":"In it's simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table otional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services and controllers.","title":"Creating Services"},{"location":"services/#adding-methods","text":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to the service. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end","title":"Adding methods"},{"location":"services/#adding-properties","text":"Again, services are just tables. So we can simply add in fields as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retreive points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {}","title":"Adding properties"},{"location":"services/#using-methods-and-properties","text":"Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points = points + amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end","title":"Using methods and properties"},{"location":"services/#using-events","text":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Event module and create PointsChanged event: local Event = require ( Knit . Util . Event ) PointsService . PointsChanged = Event . new () -- Modify AddPoints event: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points -- Fire event, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end","title":"Using events"},{"location":"services/#knitinit-and-knitstart","text":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under Execution Model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up you service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use.","title":"KnitInit and KnitStart"},{"location":"services/#cleaning-up-unused-memory","text":"Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer.","title":"Cleaning Up Unused Memory"},{"location":"services/#client-communication","text":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning.","title":"Client Communication"},{"location":"services/#methods","text":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points )","title":"Methods"},{"location":"services/#events-server-to-client","text":"We should also create an event that we can fire for the clients when their points change. We can use the Event module again, and just put one within the Client table: 1 PointsService . Client . PointsChanged = Event . new () Under the hood, Knit is creating a RemoteEvent linked to this event. This is a two-way event (like a tranceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this event too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client event: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for the event: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end )","title":"Events (Server-to-Client)"},{"location":"services/#events-client-to-server","text":"Events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just role with it. We will create another client-exposed event called GiveMePoints which will randomly give the player points. Again, this is nonesense in the context of an actual game, but useful for example. Let's create the event on the PointsService: 1 PointsService . Client . GiveMePoints = Event . new () Now, let's listen for the client to call this event. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this event, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the event like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the event: PointsService . GiveMePoints : Fire ()","title":"Events (Client-to-Server)"},{"location":"services/#full-example","text":"","title":"Full Example"},{"location":"services/#pointsservice","text":"At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Event = require ( Knit . Util . Event ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed events/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Event . new () -- Client exposed events: PointsService . Client . PointsChanged = Event . new () PointsService . Client . GiveMePoints = Event . new () -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points = points + amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Event . new (); Client = { PointsChanged = Event . new (); GiveMePoints = Event . new (); }; } -- The rest of code here","title":"PointsService"},{"location":"services/#client-consumer-localscript","text":"Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): andThen ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Client Consumer LocalScript"}]}